edn
===

extensible data notation [eed-n]

# 原理

**edn** 是一种可扩展的数据记法。一个 **edn** 的超集已被 Clojure 用于表示程序，且它被 Datomic 
及其他应用用作一种数据传输格式。本规格说明书以独立于这些及其他特定用例场景的方式来描述 **edn** ，
以帮助促进在其他语言中读写器的实现及其他方面的使用。

**edn** 支持大量的内建元素，且扩展元素由其他元素来定义。缺乏这种机制的数据格式用户必须依赖于约定
或者上下文来传达不包含在基本集合中的元素。这极大地复杂化了应用逻辑，违背了格式的外观上的简单性。
**edn** 很简单，同时在不需要约定及复杂的上下文敏感逻辑的情况下足够强大以满足应用需求。

**edn** 是一个针对 _values_ 的传输系统。它不是一个类型系统，也没有模式。
它也不是一个用于表示对象的系统 - 它没有引用类型，
其消费者也不该有这样的期待 - 在读取某些 **edn** 内容中两个相等元素会生成唯一的标识 - 
除非某种读取器的实现自行声明了该承诺。
因此生成的结果值应该是不可变的，且读取器实现生成的值应尽可能地确保这一点。

**edn** 是一系列针对可接受  _elements_ 的定义。一种 **edn** 的使用方式可能是一个流或包含元素的文件，
但它可能是像如在某个 HTTP 查询参数中的单个元素的传达那样小。

在顶层没有闭合元素。因此 **edn** 适合流式及交互式应用。

**edn** 中基本元素集合意味着包括了对大多数编程语言通用的基本数据结构集。
虽然 **edn** 指定了这些元素如何在文本中格式化，它并不指示在消费者端生成的结果的表示。
一个行为良好的读取器库应该努力将这些元素对应于编程语言中具有类似语义的类型。

# Spec

当前本规格说明书是非正式的，我们会从实现者那里收集反馈。随后将会有更严谨的描述，即 BNF 。

## 综合考量

**edn** 元素、流及文件应使用 [UTF-8](http://en.wikipedia.org/wiki/UTF-8) 编码。

元素通常由空白来分隔。空白，除了在字符串中，是不重要的，也不需要在转换时保留多余的空白。
逗号也被认为是空白，除非在字符串中。

定界符 `{ } ( ) [ ]` 不需要用空白来和邻接元素分离。

### # 分派符

由 `#` 开头的符号是保留的。`#` 后的字符决定了其行为。其中的分派
 `#{` (sets), `#_` (discard), #alphabetic-char (tag) 定义如下。
`#` 不是定界符。

## 内置元素

### nil

`nil` 表示 nil, null 或 nothing 。它应被读作目标平台上具有类似意义的一个对象。

### booleans

`true` 和 `false` 应被映射到布尔值。

如果一个平台对 true 和 false 具有典型值，即布尔值的进一步语义为所有 `true` 的实例产生对应的(恒等的)值，
对 `false` 也一样。

### strings

字符串由 `"double quotes"` 封闭。它可以跨多行。字符串中支持标准的 C/Java escape 字符 `\t \r \n`。

### characters

字符由一个反斜杠前导：`\c`。 `\newline`、 `\return`、 `\space` 和 `\tab` 分别产生响应的字符。
反斜杠不能后跟空白。

### symbols

符号用于表示标识符，且应该映射到除了字符串的其他东西，如果可能的话。

符号由一个跟非数字字符开头，后可包含任意个字母数字字符和 `. * + ! - _ ? $ % &amp; =`。
如果 `-`、 `+` 或 `.` 是第一个字符，第二个字符必须是非数字的。
另外， `: #` 在不作为第一个字符时，允许作为符号的构成字符。

`/` 在符号中具有特殊意义。它在符号中仅可用一次以分隔 _prefix_ (常是一个命名空间) 和 _name_ ，
如 `my-namespace/foo`。
`/` 本身是一个合法的符号，但其他情况下如果符号包含 `/` 时 _prefix_ 和 _name_ 都不能为空。

如果一个符号有一个 _prefix_ 和 `/`，则紧跟的 _name_ 部分应该作为整体遵循符号的首字符限制。
这是为了避免在读取那些前缀被假定为隐式包含的命名空间并因此而省略的上下文发生歧义。

### keywords

关键字是通常指向它们自身的标识符。它们在语义上类似于枚举值。
关键字遵循符号的规则，除了它们可以（必须）以一个冒号开头，如 `:fred` 或 `:my/fred`。
如果目标平台无法区分关键字类型和符号类型，相同的类型可以无冲突地使用，
因为关键之强制的前导符 `:` 对符号而言是不允许的。

如果目标平台支持拘束的概念，关键字的进一步的语义是所有相同关键字的实例产生同一个对象。

### integers

整数由数字 `0` - `9` 组成，可选由 `-` 前缀以指示一个负数，或者 （冗余的）`+` 指示正数。
整数可有 `N` 后缀以指示期望有任意的精度。-0 是一个有效数字，和 0 等价。

### floating point numbers

64-bit (double) 精度是期望的。

    floating-point-number
      int M
      int frac
      int exp
      int frac exp
    int
      digit
      1-9 digits
      + digit
      + 1-9 digits
      - digit
      - 1-9 digits
    frac
      . digits
    exp
      ex digits
    digits
      digit
      digit digits
    ex
      e
      e+
      e-
      E
      E+
      E-

另外，浮点数可有后缀 `M` 以指示期望有任意的精度。

### lists

列表是一个值的序列。列表由零或多个封闭在括号 `()` 中的元素来表示。注意列表可以是异质的。
 
    (a b 42)

### vectors

向量是一个支持随机访问的值的序列。向量由零或多个封闭在中括号 `[]` 中的元素来表示。注意列表可以是异质的。

    [a b 42]

### maps

映射是一个键值间关联的集。映射由零或多个封闭在花括号 `{}` 中的键值对来表示。
每个键最多可出现一次。键值对出现的顺序不关联任何语义。

    {:a 1, "foo" :bar, [1 2 3] four}

注意键和值都可以是任何类型的元素。上面逗号的使用时可选的，因为它们被解析为空白。

### sets

集合是唯一值的集。集合零或多个封闭在前缀 `#` 的花括号 `#{}` 中的元素来表示。
元素出现的顺序不关联任何语义。注意集合可以是异质的。

    #{a b [1 2 3]}

## tagged elements

**edn** 通过简单的机制来支持可扩展性。`#` 紧跟一个以字母字符开始的符号表示
_该符号_ 是一个 **_tag_**。一个标签指示 _随后的元素_ 的语义解释。
它预期读取器的实现将允许客户端为指定的标签注册处理器。
当遇到一个标签时，读取器将首先读取后一个元素，然后将其值传递给相应的处理器以进一步解释，
然后处理器的结果将被作为该标签 + 标记的元素所产生的数据值，即读取一个标签和标记的元素产生一个值。
该值是需被返回给程序的值，且读取器不再将其解释为 **edn** 数据。

该过程会自下而上来处理理解的或者内建的元素。

因此你可以由(且仅能由)其他可读元素来构建新的不同的可读元素，保持扩展器和扩展消费者和文本业务的分离。

标签的语义，和标记的元素的类型和解释由该标签的管理者来定义。

    #myapp/Person {:first "Fred" :last "Mertz"}

若一个读取器遇到一个尚未注册处理器的标签，其实现可以选择报告一个错误，或者调用一个特定的
'未知元素' 处理器，或者创建一个众所周知的包含了标签和标记元素的通用表示，如果它合适的话。
注意那些非错误策略使得阅读器能够读取任何所有的 **edn**，尽管可能不了解任何扩展存在性的细节。

### 标签的规则

不带前缀的标签符号由 **edn** 保留作为使用标签系统的内建定义。

用户标签 _**必须**_ 包含一个前缀组件，它可以是由用户所特有的 (如商标或领域) 或在交流上下文中已知是唯一的。

标签 _可以_ 为标记的元素指定多于一种格式，如同时有字符串和一个向量表示。

标签本身不是元素。没有相应标记元素的标签是一个错误。

## 内建标记元素

### #inst "rfc-3339-format"

一个时间上的瞬间。标记元素是一个
[RFC-3339](http://www.ietf.org/rfc/rfc3339.txt) 格式的字符串。

`#inst "1985-04-12T23:20:50.52Z"`

### #uuid "f81d4fae-7dec-11d0-a765-00a0c91e6bf6"

一个 [UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier)。
其标记元素是一个典型的 UUID 字符串表示。

## 注释

如果在字符串外遇到一个 `;` 字符，该字符及其后所有直到下一行的字符都被忽略。

## 丢弃

`#` 紧随一个 `_` 是一个丢弃序列，指示下一个元素（不管是否有空白将其和 `#_` 分隔开）应被读取并丢弃。
注意下一个元素必须依旧是一个可读的元素。读取器在需被丢弃的元素的处理过程中不应该调用用户提供的标签处理器。

    [a b #_foo 42] =&gt; [a b 42]

丢弃序列不是一个元素。没有紧随元素的丢弃序列是一个错误。

## 等价性

集合和映射需要它们的元素和键分别是唯一的，它需要一种机制来决定两个值是否是唯一的 （即相等的）。

nil、布尔值、字符串、字符和符号和具有相同 **edn** 表示的类型相等。

整数和浮点数仅在具有相同的量级、_类型和精度_ 时才相等。混合数值类型和精度作为映射/集合的键/元素，
或作为组成部分，是不推荐的。

序列 （列表和向量）相等仅在于元素的数量相同，且其中的每一个相应对的元素（根据序号）相等的序列。

集合相等仅在于具有相同数量的元素，且对一个集合中的每个元素，另一个集合中也同时存在等价元素。

映射相等仅在于具有相同数量的键值对，且对一个映射中每个键值对，
另一个映射中也存在一个相等的键且映射到相等的值。

标记元素必须定义其自己的等价性语义。#uuid 元素相等，如果它们的典型的表示是相等的。
#inst 元素相等，如果它们的表示字符串根据 [RFC-3339](http://www.ietf.org/rfc/rfc3339.txt)
指示相同的时间戳。